# State Machine {#state_machine}

Bittern cache is inspired by hardware caches and follows the state machine model
for all cache state transitions.
Each cache operation
(cache read miss, cache read hit, cache write miss, cache write hit, ....)
has a corresponding state transition "path".

## Transition Paths

The three possible "stable" cache states are:

* INVALID
* VALID_CLEAN
* VALID_DIRTY

The actual state transitions are many more due to factors which multiply the
complexity of the state machine:
* Having to clone data (rather than doing in-place updates).
* Having to handle both writethrough (WT) and writeback (WB) modes.
* Having to handle transitions initiated by either explicit IO requests and
  implicit IO requests generated by Invalidator and Background Writer threads.
* Having to handle partial writes (Bittern will only do PAGE_SIZE transfers
  to/from the cache, so partial page writes are transformed in
  read-modify-write update transactions).

The following are all the possible cache state transitions:
* TS_READ_MISS_WTWB_CLEAN
* TS_READ_HIT_WTWB_CLEAN
* TS_READ_HIT_WB_DIRTY
* TS_WRITE_MISS_WT
* TS_WRITE_MISS_WB
* TS_WRITE_HIT_WT
* TS_P_WRITE_HIT_WT
* TS_WRITE_HIT_WB_CLEAN
* TS_P_WRITE_HIT_WB_CLEAN
* TS_WRITE_HIT_WB_DIRTY_ORIGINAL
* TS_P_WRITE_HIT_WB_DIRTY
* TS_WRITE_HIT_WB_DIRTY
* TS_P_WRITE_MISS_WT
* TS_P_WRITE_MISS_WB
* TS_WRITEBACK_WB
* TS_WRITEBACK_INV_WB
* TS_CLEAN_INVALIDATION_WTWB
* TS_DIRTY_INVALIDATION_WB
* TS_VERIFY_CLEAN_WTWB

## Theory of Operation

The general approach of a cache operation is as follows:
* Lock the cache block and change its state from the initial "stable" state.
  to a transient cache state. The transient cache state indicates that
  the cache block is in use and cannot be used by another transaction
  (the cache block use count is also incremented, so technically we don't
  need to do this).
* Start the main state machine and go thru all state transitions.
* "Finalize" the cache transaction by going to the final "stable" state.

By way of example, this is how a cache read miss is handled:

* INVALID --> VALID_CLEAN_NO_DATA:
  An invalid cache block is allocated to satisfy
  the cache fill operation. At this point all the metadata is properly set up
  (including indexing in the red-black lookup tree), but there is no data yet.
* VALID_CLEAN_NO_DATA --> VALID_CLEAN_READ_MISS_CPF_DEVICE_START:
  An asynchronous read from the cached device into the cache buffer is
  initiated.
* VALID_CLEAN_READ_MISS_CPF_DEVICE_START -->
  VALID_CLEAN_READ_MISS_CPF_DEVICE_END:
  Data is copied to userland. An asynchronous cache data and metadata is
  initiated.
* VALID_CLEAN_READ_MISS_CPF_DEVICE_END -->
  VALID_CLEAN_READ_MISS_CPT_CACHE_END:
  Everything is complete, resources are released.
* VALID_CLEAN_READ_MISS_CPT_CACHE_END --> VALID_CLEAN:
  Transaction is complete.

## Cache Operations

The @ref cache_state_transitions array contains the list of all
cache transitions. Right now this array is used to simply verify that the
correct cache transition is made, whereas the actual state transition is
explictly made by the per-state transition specific code called by
@ref cache_state_machine.

This provides redundant checking that the state transition code matches
the expected transitions. Once the codebase is stable the code should be
simplified and we should just be using a state transition table instead
of a hand crafted switch statetement in @ref cache_state_machine.

Every state transition path is "documented" in the state transition table
and in comments in the main code. This information needs to be collected and
centralized in a single document for better readability.

## State Update Rules

A cache update operation necessitates a data write followed by a metadata write.
Because this sequence is non atomic, certain state transitions are not possible.
Chief among them is cache eviction followed by cache fill.
Say a cache block X which caches data A needs to be evicted so it can be
reused for new cache entry B.

The direct approach would be:
~~~~~~~~~~~~~
        write B on data(X)
        update metadata(X) to B
~~~~~~~~~~~~~

A crash in the middle introduces the danger of data corruption because
on restore the metadata would point to A with data content of B. In most
cases the restore code will detect that because of a crc32c checksum
mismatch. In the case of a collision however,
this corruption will go undetected.

The way eviction is addressed is by first invalidating X, and then doing
a cache fill with the new data.
The other case where this can be an issue is in-place-update, which is one
of the reasons why write-cloning is used.

## Code flow

* @ref cache_map_workfunc calls one of the
  "handler" functions
  @ref cache_handle_cache_hit,
  @ref cache_handle_cache_hit_write_clone,
  @ref cache_handle_cache_miss.
* The "handler" function decides which transition path to go thru,
  begins the state transition with @ref cache_state_transition_initial,
  and calls the state machine @ref cache_state_machine.
* @ref cache_state_machine calls the state machine handler for the
  current state. The handler will do the needed action and advance to the next
  state via @ref cache_state_transition3.
  This action is repeated until the last state is reached.
* The state machine handler for the last state will terminate the transaction
  and advance to the final "stable" state via
  @ref cache_state_transition_final.
